// Node用的V8引擎
// V8引擎内存回收机制。新生代内存（from），新生代内存（to），老生代内存。
// 大小：64位系统1.4G，32位0.7G；新生代64M，16M，老生代1400M，700M
// 原因：1.js设计之初为了浏览器，前端特点-不持久化，执行一遍就回收了，因而1.4够用
// 2.js回收内存的时候，会暂停执行。回收一次100Mb，需要6ms（大约）
// 简单说，新生代就是复制，老生代就是标记删除、整理（使用过和没用过的内存连续）--比如，数组必须是连续的内存空间
// 新生代经历过回收还存在，就变成老生代了；或 to空间使用了25%，就变成老生代。

// window的performance是内存
// node看内存：process.memoryUsage()
// node 是c++写的，因而有分配空间能力。扩容方法：？

// 局部变量和全局变量

// 定时和空间不够回收

// 优化内存：
// 1.减少全局变量；2.用完及时销毁；3.使用匿名自执行函数将全局变局部；4.闭包现在不一定会造成内存溢出，引用才有可能

// 防止内存泄漏--避免  滥用缓存，大内存量操作
// 1.避免用V8缓存，如，用redis，缓存加锁（即增加限制条件if等）；数组在前边插和删会使后边的内存自动对齐，因而比较长的时候会造成大内存操作？

// delete在严格模式下有bug
// null是保留字，undefined是变量（undefined=123）
function a() {
    var size = 20*1024*1024
    var arr1 = new Array(size)
    return arr1
}
a();
//...
// 此时并不会
var b = a()
var c = a()
//...
//多了就会溢出

// 大文件上传，切片
// file，blod，slice方法分割，参数是首尾